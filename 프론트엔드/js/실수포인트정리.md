# null과 typeof

null에 typeof 연산을 할 때 결과값이 null이 아님 체크할 때는 일치연산자 이용해야함.

```js
let test = null;
console.log(typeof test); // object
console.log(test === null); // true
```

# symbol

심볼은 개발중에 자주 안쓰게 되긴 해서 여기다가 정리해둔다.  
심볼은 이름 충돌의 위험을 없애기 위해 도입된 타입이다. Symbol함수로 생성된 값은 유일하다.  
주로 객체 프로퍼티 키의 유일성을 보장하기 위해 사용하는 것 같다.  
Symbol을 만들때 주어지는 인자가 같더라도 결과물은 유일하다.

```js
let key = Symbol("key");
let key2 = Symbol("key");

console.log(key === key2); // false

const obj = {};
obj[key] = "value";
```

# var 키워드 변수의 중복 선언

var 키워드로 선언된 변수는 중복 선언이 되어도 에러가 발생하지 않는다.  
하지만 var키워드로 변수를 선언하면 변수의 유효범위가 블록레벨이 아니라 함수 레벨을 따르므로 전역 변수를 남발하기 쉽고 이름이 겹치는 문제에도 예민하게 반응을 해야한다.  
ES6를 사용할 수 있는 상황이라면 const let키워드로 변수를 선언하는것이 좋다.

```js
var x = 1;
console.log(x); // 1

var x = 100;
console.log(x); // 100
```

# var의 호이스팅

호이스팅이란 프로그램에서 선언문이 해당 Scope의 선두로 이동된 것처럼 동작하는 특성을 말하는데, 이는 다른 언어와 구별되는 자바스크립트의 특징이다. 선언문만 호이스팅 되고 대입문은 호이스팅 되지 않기 때문에 선언되기 전에 참조해도 에러가 발생하지 않고 undefined값을 가지고 있게 된다. 참고로 let과 const도 호이스팅은 일어나지만 var와는 약간 다르게 동작하는데 이는 추후에 정리하도록 하자.

추가적으로 좀더 기술적으로 설명을 하자면 실행 컨텍스트에서 변수 선언문은 선언단계와 초기화 단계가 동시에 이루어지고 나중에 할당 단계에 이르게 되는데 선언 단계와 초기화 단계에서는 변수가 변수객체에 등록이 되고 초기화 단계에서는 undefined로 값이 초기화 된다는 것이다. 근데 위에 있는 설명이 더 읽기 좋은 것 같다.

```js
console.log(foo); // undefined
var foo = 123;
console.log(foo); // 123
{
  var foo = 456;
}
console.log(foo); // 456
```

# +단항 연산자의 쓰임새

숫자 타입이 아닌 피 연산자에 사용하면 값을 숫자형으로 변환하는데 사용 할 수 있다.  
다만 한번에 의도를 파악하기 쉽지 않은 코드이기 때문에 안 사용하는것이 좋을 것 같다.

```js
+"10";
```

# == 과 ===의 차이

| 기호 | 설명             |
| ---- | ---------------- |
| ==   | 값이 같음        |
| ===  | 값과 타입이 같음 |

===을 사용해서 비교하는 것이 더 안전함.

# NaN 과 일치비교 연산자의 특성

```js
console.log(NaN === NaN); // false
```

NaN은 유일하게 자기 자신과 일치비교 연산자를 수행했을때 다르다고 나오는 값이다. 주의필요!
NaN인지 확인하고 싶다면 isNaN 함수를 사용한다

```js
console.log(isNaN(NaN)); // true
```

# Symbol 의 형변환

symbol은 문자열로 또는 숫자형 변환을 하게 되면 TypeError가 생긴다

```js
Symbol() + ""; // TypeError!
+Symbol(); // TypeError !
```

# 객체 리터럴 방식 vs Object 생성자 방식

객체를 생성하는 방법중 객체 리터럴을 이용하는 방식과 Object 생성자 방식을 이용하는 방식을 살펴보자.

```js
const obj1 = {}; // 객체 리터럴
const obj2 = new Object(); // 생성자 함수 이용
```

객체 리터럴 방식으로 생성된 객체는 결국 Object 생성자 함수를 이용해 객체를 생성하는 것을 단순화 시킨 축약 표현이다. 자바스크립트 엔진은 객체 리터럴 방식으로 객체를 생성하는 코드를 만나면 내부적으로 Object 생성자 함수를 이용하여 객체를 생성한다.

# new 키워드

자바스크립트에서 생성자 함수는 말 그대로 함수일 뿐이다. 다만 new 키워드를 붙여서 함수를 호출 하면 생성자 함수로 동작하는 것이다. 이는 일반함수에 new 키워드를 붙여서 호출하면 생성자 함수 처럼 동작할 수 있는 것을 의미하는데 이를 피하기 위해서 생성자 함수는 파스칼 케이스로 이름을 짓는 편이다. new 키워드를 이용해 함수를 호출하면 this 바인딩이 일반적인 함수랑 다르게 동작하는데 이는 나중에 정리하도록 한다.

# 프로퍼티 접근 []

```js
const person = {
  weight: 100,
  height: 200,
  name: "kim",
};

console.log(person[name]); //대괄호를 이용해 프로퍼티에 접근할 때는 ''로 감싸준다!
console.log(person["name"]);
```

# for - in 문

for - in 문을 이용하면 객체에 포함된 모든 프로퍼티에 대해 루프 수행이 가능하다.  
다만, 순서는 보장되지 않는다고 한다.

배열에는 사용하지 않는것이 좋은데 그 이유는 다음과 같다.

- 객체의 경우 프로퍼티의 순서가 보장되지 않는다, 배열은 순서를 보장하는 데이터 구조이지만 객체와 마찬가지로 순회시 순서를 보장하지 않아서 별로 좋은 선택이 아니다.
- 배열 요소들만 순회하는것이 아니라 다른 프로퍼티에도 접근하게 된다.

```js
const person = {
  weight: 100,
  height: 200,
  name: "kim",
};

for (const prop in person) {
  console.log(person[prop], prop);
}
```

# for - of 문

배열의 요소만 for -in 문처럼 순회를 하면서 순서를 보장하고 싶을 때 사용하면 좋다.

```js
const arr = [1, 2, 3, 4];

for (const val of arr) {
  console.log(val);
}
/*
1
2
3
4

*/
for (const [idx, val] of arr.entries()) {
  console.log(idx, val);
}
/* 
0 1
1 2
2 3
3 4
*/
```
