# Component

```js
<Test name="Kim" prop={false} />
```

- src, class, name, props 밖에서 넣어주는 데이터
- HTML CSS JS를 합쳐서 내가 만든 일종의 태그

# Component Based Development

웹 페이지 전체를 컴포넌트로 나눠 개발하는 방식

# Virtual DOM

- 가상의 돔 트리를 사용한다.
- 이전 상태와 이후 상태를 비교한다.
- 바뀐 부분을 찾아내서 자동으로 바꾼다.

# Client Side Rendering

1. 서버가 HTML을 보내준다
1. Browser가 JS를 다운로드 받는다. (이때는 웹이 실행 X)
1. 브라우저가 리액트를 실행한다(여기 까지는 웹이 동작하지 않는다.)
1. 리액트가 실행이되면 화면이 보이고 상호작용 가능하다.

# Server Side Rendering

1. 초기에 렌더링 가능한 HTML을 보내준다
1. 브라우저는 페이지를 띄운다 이때 보이기는 가능하다.
1. 그다음 JS를 다운 받는다
1. 리액트를 실행한다
1. 이제 상호작용이 가능하다.

# 리액트가 하는일

## 핵심 모듈

```js
// 1. 리액트 컴포넌트를 HTMLElement 연결하기
import ReactDOM from 'react-dom';
// 2. 리액트 컴포넌트 만들기
import React from 'react;
```

```js
ReactDOM.render(
  <HelloMessage name="Taylor" />,
  document.getElementById("hello-example") // 컴포넌트를 실제 돔에 연결
);
```

```js
class HelloMessage extends React.Component {
  render() {
    return <div>Hello {this.props.name}</div>;
  }
}
```

# 리액트 이전 프론트엔드

HTML로 문서 구조를 잡고,  
CSS로 스타일을 입히고,  
JavaScript로 DOM을 조작한다.

# 리액트 모방해보기

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        border: 0;
      }

      #root p {
        color: white;
        font-size: 20px;
        background-color: green;
        text-align: center;
        width: 200px;
      }

      #btn_plus {
        background-color: red;
        border: 2px solid #000;
        font-size: 15px;
        width: 200px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <button id="btn_plus">+</button>
    <script type="text/javascript">
      //컴포넌트에는 데이터가 들어있음
      const component = {
        message: "init",
        count: 0,
        // 데이터를 이용해 HTML을 만들어 낸다.
        render() {
          return `<p>${this.message} : ${this.count}</p>`;
        },
      };

      // DOM에 component가 뿌려주는 html을 삽입해 줌.
      function render(rootElement, component) {
        rootElement.innerHTML = component.render();
      }
      // 초기화
      render(document.querySelector("#root"), component);

      // 상태가 변경되면 render함수를 다시 호출해준다.
      document.querySelector("#btn_plus").addEventListener("click", () => {
        component.message = "update";
        component.count = component.count + 1;

        render(document.querySelector("#root"), component);
      });
    </script>
  </body>
</html>
```

# 리액트 컴포넌트 만들기

## Hooks 이전

- 컴포넌트 내부에 상태가 있다면? => class
- 컴포넌트 내부에 상태가 없다면?
  - 라이프사이클을 사용해야 한다면? => class
  - 라이프 사이클에 관계가 없다면? => function

## Hook 도입 후

- class
- function

# Class 컴포넌트

```js
import React from "react";

class ClassComponent extends React.Component {
  render() {
    return <div>Hello</div>;
  }
}

// 사용
//<ClassComponent />
```

# 함수 컴포넌트

```js
//정의 1
function FunctionComponent() {
  return <div>Hi</div>;
}
//정의 2
const FunctionComponent2 = () => <div>hi</div>;
```

# createElement

createDOM으로 리액트에서 렌더링 될 DOM을 만들 수 있다.

```js
//1, 태그이름 문자열 type
ReactDOM.render(
  React.createElement("h1", null, `type 이 "태그 이름 문자열" 입니다.`),
  document.querySelector("#root")
);
```

```html
<div id="root">
  <h1>type 이 "태그 이름 문자열" 입니다.</h1>
</div>
```

```js
//2. 리액트 컴포넌트 type
const Component = () => {
  return React.createElement("p", null, "type이 React 컴포넌트 입니다.");
};

ReactDOM.render(
  React.createElement(Component, null, null),
  document.querySelector("#root")
);
```

```html
<div id="root">
  <p>type 이 "React 컴포넌트" 입니다.</p>
</div>
```

```js
// 3. React.Fragment
ReactDOM.render(
  React.createElement(
    React.Fragment,
    null,
    `type이 React Fragment 입니다.`,
    `type이 React Fragment 입니다.`,
    `type이 React Fragment 입니다.`
  ),
  document.querySelector("#root")
);
```

```html
<div id="root">
  type이 React Fragment 입니다. type이 React Fragment 입니다. type이 React
  Fragment 입니다.
</div>
```

Fragment를 사용하면 최상위 태그가 존재하지 않고 병렬적으로 배치 됩니다.

## 한계

api의 사용성이 굉장히 불편하다.

```js
// 4. 복잡한 리액트 엘리먼트 모임
// <div>
//   <div>
//     <h1>주제</h1>
//     <ul>
//       <li>React</li>
//       <li>Vue</li>
//     </ul>
//   </div>
// </div>
ReactDOM.render(
  React.createElement(
    "div",
    null,
    React.createElement(
      "div",
      null,
      React.createElement("h1", null, "주제"),
      React.createElement(
        "ul",
        null,
        React.createElement("li", null, "React"),
        React.createElement("li", null, "Vue")
      )
    )
  ),
  document.querySelector("#root")
);
```

# JSX

javascript에서 html 코드와 비슷한 문법으로 ReactDOM 을 생성하는 문법  
실제 지원하는 문법이 아니므로 babel을 이용해 순수 자바스크립트로 변환 해 주어야 한다.

가독성이 정말 좋아진다.  
또한 문법 검사가 엄격하여 버그 잡기가 좋음.

```js
ReactDOM.render(
  <div>
    <div>
      <h1>주제</h1>
      <ul>
        <li>React</li>
        <li>Vue</li>
      </ul>
    </div>
  </div>,
  document.querySelector("#root")
);
```

## JSX 규칙

- 최상위 요소는 하나여야 한다.
- 최상위 요소를 리턴하는 경우 ()로 감싸주어야 한다.
- 자식들을 바로 랜더링하고 싶으면 <>자식</>를 사용한다. => Fragment
- 자바스크립트 표현식을 사용하려면, {표현식} 을 사용한다.
- if문은 사용할 수 없다 삼항 연산자 혹은 && 를 사용해야 한다.
- style을 통해 인라인 스타일링이 가능하다.
- class 대신 className을 이용해 class를 적용할 수 있다.
- 자식요소가 있으면, 꼭 닫아야 하고, 자식요소가 없으면 열면서 닫아야 한다.

# Props 와 State

Props 는 컴포넌트 외부에서 컴포넌트에게 주는 데이터입니다.  
State 는 컴포넌트 내부에서 변경할 수 있는 데이터 입니다.  
둘 다 변경이 발생하면 랜더가 다시 일어날 수 있습니다.

## Render 함수

Props와 State를 바탕으로 컴포넌트를 그린다.  
그리고 Props와 State가 변경되면 컴포넌트를 다시 그린다.  
컴포넌트를 그리는 방법을 기술하는 함수가 랜더 함수이다.

```js
// props는 인자로 들어온다 객체형태로
// {message: "테스트"}
function Component(props) {
  return (
    <div>
      <h1>{props.message} 이것은 함수로 만든 컴포넌트 입니다.</h1>
    </div>
  );
}

ReactDOM.render(
  <Component message="테스트" />,
  document.querySelector("#root")
);

// props가 this.props로 들어온다
class ClassComponent extends React.Component {
  render() {
    return (
      <div>
        <h1>{this.props.message} 이것은 클래스 만든 컴포넌트 입니다.</h1>
      </div>
    );
  }
}

ReactDOM.render(
  <ClassComponent message="테스트" />,
  document.querySelector("#root")
);
```

## default Props

props를 기본값을 가지도록 설정할 수 있다.

```js
class ClassComponent extends React.Component {
  render() {
    return (
      <div>
        <h1>{this.props.message} 이것은 클래스 만든 컴포넌트 입니다.</h1>
      </div>
    );
  }

  // 클래스만 사용 가능한 방법
  static defaultProps = {
    message: "기본값2",
  };
}
// 함수에서도 같이 사용 할 수 있는 방법
ClassComponent.defaultProps = {
  message: "기본값",
};
```

## State

```js
class Component extends React.Component {
  // 항상 객체 형식이어야 한다
  // state를 설정하는 1번째 방식
  state = {
    count: 0,
  };

  constructor(props) {
    super(props);
    // state를 초기화 하는 2번째 방식
    this.state = {
      count: 0,
    };
  }

  render() {
    return (
      <div>
        <h1>{this.props.message} 이것은 클래스 만든 컴포넌트 입니다.</h1>
        <p>{this.state.count}</p>
      </div>
    );
  }
  // 렌더가 끝난 직후에 호출되는 라이프사이클 메소드
  componentDidMount() {
    setTimeOut(() => {
      // 상태를 변경하기 위해서는 setState 함수를 써 주어야 한다.
      this.setState({
        count: this.state.count + 1,
      });

      // 상태를 변경할때 함수를 인자로 넘기면 이전상태를 인자로 넘겨준다.
      this.setState((prev) => {
        const newState = { count: prev.count + 1 };
        return newState;
      });
    }, 1000);
  }
}
```

# Event Handling

- camelCase만 사용가능
  - onClick, onMouseEnter
- 이벤트에 연결된 자바스크립트 코드는 함수입니다.
  - 이벤트={함수} gudtlr
- 실제 DOM 요소에만 사용 가능
  - 리액트 컴포넌트에 전달하면 그냥 props로 전달 됨.

```js
class Component extends React.Component {
  render() {
    return <button onClick={() => console.log("test")}>버튼</button>;
  }
}
```

onClick에 들어가는 함수를 메소드로 뺄 경우 this bind에 대한 이슈가 생긴다.

그렇게 되는 이유는 메서드가 이벤트로 등록하게 되는 과정에서 메서드와 컴포넌트의 인스턴스의 관계가 끊겨버리기 때문이다.

bind를 하기 위해서 bind함수를 쓰거나 화살표 함수를 사용 해 주면 된다.

```js
class Component extends React.Component {
  state = {
    count: 0,
  };

  constructor(props) {
    super(props);

    this.click = this.click.bind(this);
  }

  increase() {
    this.setState((state) => ({
      ...state,
      count: this.state.count + 1,
    }));
  }

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={increase}>+</button>
      </div>
    );
  }
}
```

# Component Lifecycle

리액트 컴포넌트는 탄생부터 죽음까지 여러지점에서 개발자가 작업이 가능하도록 오버라이드 하게 해준다.

```js
class App extends React.Component {
  state = {
    age: 39,
  };
  //최초 한번 호출 (update시에는 호출 되지 않는다)
  constructor(props) {
    super(props);

    console.log("constructor", props);
  }
  // 그릴 때 호출
  render() {
    console.log("render");
    return (
      <div>
        <h2>
          {this.props.name} - {this.state.age}
        </h2>
      </div>
    );
  }
  // render 호출 전에 호출 (update시에는 호출 되지 않는다)
  // getDerivedStateFromProps로 이름 변경
  // componentWillMount() {
  //   console.log("componentWillMount");
  // }

  // return 부분에 새로운 state를 반환해주면 된다 setState를 할 필요가 없다.
  // render가 실행되기 전에 거의 무조건 불린다.
  static getDerivedStateFromProps(nextProps, prevState) {
    return null;
  }
  // render 호출 후에 호출 (update시에는 호출 되지 않는다)
  componentDidMount() {
    console.log("componentDidMount");
  }

  // update lifecycle
  // nextProps는 바뀌게될 Props이다.
  // state의 변경에 반응하지 않는다.
  // props의 변경에따라 state를 변경해야 한다면 여기서 setState를 이용하면 다음 이벤트로 가는것이 아니라 한번에 변경 가능하다.
  // getDerivedStateFromProps로 이름 변경
  // componentWillReceiveProps(nextProps) {
  //   console.log("componentWillReceiveProps", nextProps);
  // }

  shouldComponentUpdate(nextProps, nextState) {
    console.log("shouldComponentUpdate", nextProps, nextState);
    return true; // true를 리턴하면 이어서 렌더링 할 준비를함 false일 경우 state나 props를 변경했더라도 렌더링을 하지 않음 state는 바뀐다!
  }
  // 컴포넌트가 재 렌더링되기 전에 불림
  // 여기서 setState같은 것을 쓰면 다시 위의 라이프 사이클로 돌아갈 것 같음.
  // getSnapshotBeforeUpdate로 이름 변경
  // 컴포넌트의 이전상황을 다음 라이프사이클 메소드로 넘겨줄 때 사용하면 좋은듯
  // componentWillUpdate(nextProps, nextState) {
  //   console.log("componentWillUpdate", nextProps, nextState);
  // }
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (prevState.list.length === this.state.list.length) return null;

    const list = document.querySelector("#list");
    return list.scrollHeight - list.scrollTop;
  }
  // render가 발생한후
  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log(snapshot);
    if (snapshot === null) return;
    const list = document.querySelector("#list");
  }
  // 컴포넌트가 사라지기 전에 호출
  // interval 같은 내용을 정리해주기 위해서 사용
  componentWillUnmount() {}

  // 에러가 발생하면 호출된다!
  // 자기 자신에게 문제가 있을 때는 catch가 안됨
  // 가장 상위 컴포넌트에서 처리하는것이 좋음
  componentDidCatch(error, info) {}
}
```
