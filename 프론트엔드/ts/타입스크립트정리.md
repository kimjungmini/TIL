# 타입 스크립트란?

타입 스크립트란 자바스크립트에 타입을 부여한 언어이다.  
자바스크립트 개발을 하다보면 변수에 타입이 동적으로 할당된다는 점이 굉장히 불편한데 타입스크립트를 이용하면 다음과 같은 점을 해결할 수 있다.

1. 타입안정성 - 타입스크립트에는 변수의 타입이 동적으로 변하지 않는다.
2. 개발생산성 - ide자체에서 자동완성을 조금 더 잘 지원 해 주기 때문에 개발 생산성이 약간 더 좋아진다.

---

## 기본타입

### **boolean**

```ts
let isDone: boolean = false;

isDone = true;

console.log(isDone); // 'boolean'

let isOk: Boolean = true;

let isNotOk: boolean = new Boolean(true);
```

기본 타입을 나타낼 때는 대문자가 들어간 타입이 아닌 소문자를 이용해서 타입을 지정해 주는것이 좋다. 코드에 보면 : 뒤에 나타난 자료형 부분이 타입을 지정해 주는 부분이다.

원시타입으로 지정된 변수에 객체 타입의 값을 넣어주려고 하면 오류가 발생한다!

---

### **string**

```ts
let myName: string = "Kim";

myName = "Park";

let fullName: string = "Jung Kim";
let age: number = 39;

let sencetnce = `my name is ${fullname} my age is ${age}`;
```

템플릿 리터럴을 포함한 문자열은 string 형으로 타입을 지정해준다.

---

### **number**

```ts
let decimal: number = 6;

let hex: number = 0x12;

let binary: number = 0b1010;

let octal: number = 0o744;

let notANumber: number = NaN;

let underscoreNum: number = 1_000_000;
```

숫자는 number 타입으로 타입을 지정 해 준다. 10진수 뿐만아니라 여려 형식의 숫자도 지정 가능하다.

---

### **null**

```ts
let myName: string = null; // string형 타입이지만 초기값을 null로 지정하고 싶을 경우 에러!

let myNameUnion: string | null = null; // string 또는 null을 가짐 이런식으로 타입을 지정하는 것을 Union타입이라고 함

myNameUnion = "Kim";
```

null 은 null만 들어갈 수 있기 때문에 혼자서 타입을 지정하는 경우 유용하지는 않지만 union타입을 이용해서 타입을 지정할 경우 유용하게 타입을 지정할 수 있다.

---

### **symbol**

```ts
console.log(Symbol("foo") === Symbol("foo")); //false

const sym = Symbol();

const obj = {
  [sym]: "value",
};

obj[sym];
```

주로 object에 프로퍼티에 접근을 제한하기위해 사용하는 자료형이다.  
Symbol()함수를 통해 만들면 자동으로 타입이 지정된다.

---

### **object**

```ts
const person1 = { name: "kim", age: 36 };

// person1 type: {name: string, age: number}

const person2 = Object.create({ name: "mark", age: 30 });
// 주로 primitive type이 아닌 것을 나타내고 싶을 때 사용한다!
```

주석에 적힌 내용처럼 타입이 원시타입이 아닐 때를 나타내고 싶을 때 주로 사용하면 좋은 타입이다.

---

### **array**

```ts
let list: (number | string)[] = [1, 2, 3, "4"];
let number_list: number[] = [1, 2, 3];
let string_list: string[] = ["1", "2", "3"];

let test_list: Array<number> = [1, 2, 3];
```

배열 타입을 지정할 때 사용하며 첫 째줄 처럼 사용할 경우 배열 요소의 타입이 한 개가 아닌경우도 지정 할 수 있다.

---

### **tuple**

```ts
const person: [string, number] = ["mark", 396];

const [first, second] = person; //구조분해 할당시에는 타이핑 필요 X
```

튜플은 배열 요소의 순서가 정해져 있어서 데이터가 구조화 되어 있을 때 사용하면 유용하다.  
위와 같은 경우에는 첫번째요소가 string 두번째 요소가 number타입이라는것을 프로그래머가 알 고 있을 때 타입을 지정할 수 있다.

---

### **any**

```ts
function returnAny(message: any): any {
  console.log(message);
}

const any1 = returnAny("리턴은 아무거나");

any1.toString();

let looselyTyped: any = {};

const d = looselyTyped.a.b.c.d; // 다시 any 결국 any의 전파

function leakingAny(obj: any) {
  const a: number = obj.num; // 누수가 막힌다.
  const b = a + 1; // 그래도 any이다.
  return b;
}

const c = leakingAny({ num: 10 }); //c도 any이다.
```

any는 어떤 값이든 들어올 수 있는 type을 말하는데 사용하기에 굉장히 편리해 보이지만, type 안정성을 보장해 주지 못하는 타입이다.

그럴꺼면 그냥 자바스크립트 쓰지 타입스크립트를 왜 쓰겠는가? 그래도 도저히 타입을 예측할 수 없을 때 사용하는 경우도 있기는 하지만 그럴 경우 unknown타입을 쓰는게 조금 더 타입의 안정성을 보장해 줄 수 있다. 어지간하면 사용하지 말자

---

### **unknown**

```ts
const maybe: unknown = true; //동적인 값이 들어와서 타입을 확실히 알 수 없을 때 사용한다.

//타입을 확정해주지 않으면 다른 곳에 할당 할 숭 없고  연산 불가능하다.

const aNumber: number = maybe; // 에러!
console.log(maybe + 1); // 에러

//typeguard 를 이용해 특정 타입임을 보장 할 수 있을 때 비로소 사용이 가능하다.

if (maybe === true) {
  const aBoolean = maybe;

  // const aString: string = maybe;
}

if (typeof maybe === "string") {
  const aString: string = maybe;
}
```

---

### **void**

```ts
function returnVoid(message: string): void {
  console.log(message);
}

const r = returnVoid("리턴이 없다");
```

함수에서 반환값이 없을 때 사용한다.

---

### **never**

```ts
function error(message: string): never {
  throw new Error(message);
}

function fail() {
  return error("failed");
}

function infiniteLoop(): never {
  while (true) {}
}

declare const a: string | number;

if (typeof a !== "string") {
  let b: number = a;
}

type Indexable<T> = T extends string ? T & { [index: string]: any } : never;

type ObjectIndexable = Indexable<{}>;

/* 
  never타입은 모든 타입의 subtype이며, 모든 타입에 할당 가능
  하지만, never에는 그 어떤 것도 할당할 수없다
  any도 never에 할당 불가능
  잘못된 타입을 넣는 실수를 막고자 할 때 사용
*/
```

함수에 선언할 경우 throw와 무한반복 처럼 함수가 정상적으로 종료되지 않는 상황을 보장해 줄 수 있고 type선언시 잘못된 타입을 넣는 실수를 막고자 할 때 사용할 수 있다고 하는데 이부분은 아직 완벽히 이해가 되지 않았으므로 나중에 다시 정리한다.
